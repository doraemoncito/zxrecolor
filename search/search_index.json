{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"About Many developers draw inspiration from older games to create some really cool and admirable works. Writing a game, however, is a hard task, so it is no wonder that many decent games never get a modern remake. Arguably, many old games can be quite frustrating for a modern player, so an appealing remake should include ceratain updates for core game mechanics. However, many other games are still enjoyable to play, and it is often sufficient to update graphics and sound to please our modern senses. At least, this kind of logic is apparent in many great remakes like Head over Heels : If a game is playable enough, and it doesn't require a complete rewrite, can we upgrade it with less effort? ZX Recoloring Project aims to provide a toolset exactly for this purpose. There is no ambition to provide a solution for implementing all sorts of ideas in all sorts of games. The main focus is on simplicity of use: you can make your favorite game noticeably different less than in an hour, and keep adding new improvements gradually. The project is maintaned by Maxim Mozgovoy in frustratingly rare moments of his spare time.","title":"About"},{"location":"index.html#about","text":"Many developers draw inspiration from older games to create some really cool and admirable works. Writing a game, however, is a hard task, so it is no wonder that many decent games never get a modern remake. Arguably, many old games can be quite frustrating for a modern player, so an appealing remake should include ceratain updates for core game mechanics. However, many other games are still enjoyable to play, and it is often sufficient to update graphics and sound to please our modern senses. At least, this kind of logic is apparent in many great remakes like Head over Heels : If a game is playable enough, and it doesn't require a complete rewrite, can we upgrade it with less effort? ZX Recoloring Project aims to provide a toolset exactly for this purpose. There is no ambition to provide a solution for implementing all sorts of ideas in all sorts of games. The main focus is on simplicity of use: you can make your favorite game noticeably different less than in an hour, and keep adding new improvements gradually. The project is maintaned by Maxim Mozgovoy in frustratingly rare moments of his spare time.","title":"About"},{"location":"deployment.html","text":"Deployment Deploying your remake is very easy: Prepare a working folder with the minimal emulator environment. It should include the files 2006.rom , bass.dll , unreal.exe , and unreal.ini . Place the sna -snapshot of the original ZX Spectrum game into the working folder. Open unreal.ini and make sure that the value of snapshot parameter matches the name of your snapshot. You can rename unreal.exe and unreal.ini into anything else like MyGame.exe and MyGame.ini , just make sure these names match. Place the content of your game folder (with pictures, sounds, and settings.txt ) into the archive named game.zip and move it into your working folder. Make sure the resources are directly in the archive, not inside some subfolder. Now you can simply convert your working folder to a regular or self-extracting archive and publish it anywhere you like! Just make sure to drop me a line , I'll be happy to know about new remakes :)","title":"Deployment"},{"location":"deployment.html#deployment","text":"Deploying your remake is very easy: Prepare a working folder with the minimal emulator environment. It should include the files 2006.rom , bass.dll , unreal.exe , and unreal.ini . Place the sna -snapshot of the original ZX Spectrum game into the working folder. Open unreal.ini and make sure that the value of snapshot parameter matches the name of your snapshot. You can rename unreal.exe and unreal.ini into anything else like MyGame.exe and MyGame.ini , just make sure these names match. Place the content of your game folder (with pictures, sounds, and settings.txt ) into the archive named game.zip and move it into your working folder. Make sure the resources are directly in the archive, not inside some subfolder. Now you can simply convert your working folder to a regular or self-extracting archive and publish it anywhere you like! Just make sure to drop me a line , I'll be happy to know about new remakes :)","title":"Deployment"},{"location":"handy-tools.html","text":"Handy tools While you can manage any recoloring project solely with the help of your favorite graphics editor, there are additional tools aimed to make this job easier. Please check them out. UnrealSpeccy Emulator UnrealSpeccy includes numerous developer-oriented instruments, and some additional means are added to our customized version. Here is a very incomplete list: Ctrl+1 , Ctrl+2 , Ctrl+3 : switch between recolored, original, and black-and-white rendering. Alt+F8 : take a screenshot. Ctrl+F8 : record a video clip (you will need to have ffmpeg.exe in the emulator folder). You can change target video format in unreal.ini : search for \"ffmpeg encoding options\". Also note that the resulting video will be placed into the \"current folder\", which is game if you have already created it. hqx Many emulators improve video output by means of hqx filter . Hqx-processed screenshots can be a good start for subsequent recoloring work. ZX Recoloring project includes a precompiled version of hqx command line tool. Run it with the original (unscaled) ZX Spectrum screenshot as an input argument to generate a double-sized hqx-improved output.bmp ZX Color Tool TODO","title":"Handy tools"},{"location":"handy-tools.html#handy-tools","text":"While you can manage any recoloring project solely with the help of your favorite graphics editor, there are additional tools aimed to make this job easier. Please check them out.","title":"Handy tools"},{"location":"handy-tools.html#unrealspeccy-emulator","text":"UnrealSpeccy includes numerous developer-oriented instruments, and some additional means are added to our customized version. Here is a very incomplete list: Ctrl+1 , Ctrl+2 , Ctrl+3 : switch between recolored, original, and black-and-white rendering. Alt+F8 : take a screenshot. Ctrl+F8 : record a video clip (you will need to have ffmpeg.exe in the emulator folder). You can change target video format in unreal.ini : search for \"ffmpeg encoding options\". Also note that the resulting video will be placed into the \"current folder\", which is game if you have already created it.","title":"UnrealSpeccy Emulator"},{"location":"handy-tools.html#hqx","text":"Many emulators improve video output by means of hqx filter . Hqx-processed screenshots can be a good start for subsequent recoloring work. ZX Recoloring project includes a precompiled version of hqx command line tool. Run it with the original (unscaled) ZX Spectrum screenshot as an input argument to generate a double-sized hqx-improved output.bmp","title":"hqx"},{"location":"handy-tools.html#zx-color-tool","text":"TODO","title":"ZX Color Tool"},{"location":"hello-world.html","text":"Hello, world! For starters, let's practice recoloring a couple of sprites in a small game titled I, Ball II . Download and extract the archive iball2.zip . It contains a minimal binary distribution of a modified open source Spectrum emulator Unreal Speccy (the main executable file is renamed into iball2.exe ), and a SNA image of I, Ball II. The snapshot is taken at the beginning of level 2, since it contains the sprites of our interest. Run the game (i.e., execute iball2.exe ) and make sure that everything works correctly. The controls are set to Sinclair joystick (keyboard keys 6, 7, 8, 9, 0). Initially, the game screen should look like this: Now let's update the sprites of yellow balls and gray boxes: Create a subfolder game inside the game folder. Here you should place both the old sprite pictures you want to substitute and their upgraded versions. For the balls and the boxes you'll need these pictures . Create in the same game subfolder a file settings.txt , containing the following lines: 0 block zx_yellowball.bmp pc_yellowball.bmp 0 pixel zx_graybrick.bmp pc_graybrick.bmp That's it! Run the game and enjoy the result: Some final notes: Recolored screen is twice wider and twice higher than the original ZX Spectrum screen, so in most cases recolored sprites should also be twice wider and twice higher than their original counterparts. Both original and recolored sprites should be stored in the BMP 24bpp format. Areas painted with the pinkish color RGB(242, 10, 242) are treated as transparent. All non-transparent pixels in the original sprites must be either black (ink) or white (paper). The configuration file settings.txt consists of lines including at least the following compulsory elements: <layer-number> <rule-type> <original-sprite> <new-sprite> Layers are needed to organize background and foreground elements properly. The system draws sprites layer by layer, so foreground sprites should be placed on higher-numbered layers. Different rule types are used here to reduce CPU load. Fast cell-precise block rules assume that the original sprites are always aligned with the borders of 8x8 pixel blocks (which is a very common case for background objects). In contrast, slower pixel-precise pixel rules perform complete searching. In our case, yellow balls never leave their initial positions, so cell-precise matching is sufficient. However, gray boxes fall down when touched, so pixel-precise matching is necessary in their case. In practice everything is usually not so simple. Keep reading!","title":"Hello, world!"},{"location":"hello-world.html#hello-world","text":"For starters, let's practice recoloring a couple of sprites in a small game titled I, Ball II . Download and extract the archive iball2.zip . It contains a minimal binary distribution of a modified open source Spectrum emulator Unreal Speccy (the main executable file is renamed into iball2.exe ), and a SNA image of I, Ball II. The snapshot is taken at the beginning of level 2, since it contains the sprites of our interest. Run the game (i.e., execute iball2.exe ) and make sure that everything works correctly. The controls are set to Sinclair joystick (keyboard keys 6, 7, 8, 9, 0). Initially, the game screen should look like this: Now let's update the sprites of yellow balls and gray boxes: Create a subfolder game inside the game folder. Here you should place both the old sprite pictures you want to substitute and their upgraded versions. For the balls and the boxes you'll need these pictures . Create in the same game subfolder a file settings.txt , containing the following lines: 0 block zx_yellowball.bmp pc_yellowball.bmp 0 pixel zx_graybrick.bmp pc_graybrick.bmp That's it! Run the game and enjoy the result: Some final notes: Recolored screen is twice wider and twice higher than the original ZX Spectrum screen, so in most cases recolored sprites should also be twice wider and twice higher than their original counterparts. Both original and recolored sprites should be stored in the BMP 24bpp format. Areas painted with the pinkish color RGB(242, 10, 242) are treated as transparent. All non-transparent pixels in the original sprites must be either black (ink) or white (paper). The configuration file settings.txt consists of lines including at least the following compulsory elements: <layer-number> <rule-type> <original-sprite> <new-sprite> Layers are needed to organize background and foreground elements properly. The system draws sprites layer by layer, so foreground sprites should be placed on higher-numbered layers. Different rule types are used here to reduce CPU load. Fast cell-precise block rules assume that the original sprites are always aligned with the borders of 8x8 pixel blocks (which is a very common case for background objects). In contrast, slower pixel-precise pixel rules perform complete searching. In our case, yellow balls never leave their initial positions, so cell-precise matching is sufficient. However, gray boxes fall down when touched, so pixel-precise matching is necessary in their case. In practice everything is usually not so simple. Keep reading!","title":"Hello, world!"},{"location":"rules-syntax.html","text":"Writing rules This section is intended to be a succint yet complete description of rule types and rule syntax. It might be a bit difficult to read it due to lack of practical examples, so make sure to check out Tips and tricks section as well. Settings file All required game transformations are performed by means of rules, listed in the game\\settings.txt file. Each line of this file is a separate rule. Empty lines and lines starting with a semicolon symbol are ignored: ; This is a comment <here-comes-my-first-rule> Rules are case-sensitive. Sprite replacement rules Each sprite replacement rule can substitute an original ZX Spectrum sprite found on the screen with its upgraded version. Recolored screen is twice wider and twice higher (512x384) than the original screen (256x192), and imposes no color limits. Sprite replacement rules are described with the following syntax: <layer-number> <rule-type>[|x,y] <original-sprite> <new-sprite> [protected|N] Layers If a game has non-blank background, it is necessary to ensure that foreground images (such as game characters) are drawn over the background rather than behind it. This can be achieved with layers: each subsequent layer is drawn only after the previous layer is complete. For example, all the sprites on the layer 1 will be drawn after all the sprites on the layer 0. The layer-number element should be an integer. Replacement rule types Currently there are two types of sprite replacement rules: block and pixel . ZX Spectrum screen is logically divided into 8x8-pixel blocks, having independent color palettes. In practice it means that immovable background elements are typically aligned with the borders of such blocks. Rules of block type search original sprites aligned with block corners only. In contrast, pixel rules check every location on the screen. There are two primary reasons to use block rules, where it is possible. First, they are much faster, since only block corner locations have to be checked. Second, they help fighting false positive matches. Sometimes, an accidental combination of pixels on the screen can form a \"match\" for a certain small sprite, causing the rule to trigger. If it is known that the original sprite is always block-aligned, we can minimize the chances of a false positive match. Rule type can be followed with an optional |x,y section, forcing the rule to be applicable to the original sprite located only in the specified position of the screen. This method is handy for detecting static elements displayed in known locations. Original sprite declaration Original sprite declaration consists of the following elements: <sprite-name>.bmp[|x1,y1,color1[|x2,y2,color2[|...]]] Color palette in ZX Spectrum is specified per 8x8 sprite block rather than per pixel. In practice it often leads to \"color clashes\" (incorrectly colored areas), apparent in many Spectrum games. For us it means that color matching is unreliable: we cannot be sure that the given sprite will always preserve its color palette. Therefore, the basic matching procedure assumes that the original sprite does not contain any color information. It should be a 24bpp BMP image, with a width equal to a multiple of 8, and actually containing pixels of these colors only: white, RGB(255, 255, 255) : background \"paper\" color; black, RGB(0, 0, 0) : foreground \"ink\" color; pinkish, RGB(242, 10, 242) : transparent color, ignored in matching operations. Sometimes, however, color information is both reliable and necessary. Thus, there is an option to specify a list of colors of individual sprite pixels. For example, the declaration my_sprite.bmp|0,0,red|0,1,yellow specifies that the match for my_sprite.bmp must have a black pixel in the top-left corner and a yellow pixel right under it. Color names are taken from the standard Spectrum vocabulary: black , blue , red , magenta , green , cyan , yellow , white . For brighter colors, add + to the color name: black+ , blue+ , red+ , magenta+ , green+ , cyan+ , yellow+ , white+ . Recolored sprite declaration Declaring recolored sprites is easier: <new_sprite>.bmp[|dx,dy] Here the optional |dx,dy part allows to specify a relative displacement of the new sprite on the screen. For example, if you want to place the new sprite just a bit higher than the original matched fragment, use <new_sprite>.bmp|0,-1 Note that the numbers here correspond to the original ZX Spectrum screen dimensions. Thus, \"-1\" will actually become \"two pixels higher\" in the final double-size render. Protected clause The [protected|N] clause is one of handy tools designed to deal with incomplete matches. It works as follows: The system identifies missing protected sprites, matched on the previous frame. For each protected sprite, the system tries to match at least N non-transparent sprite pixels in the original location. If this is operation is successful, the sprite is considered found. In effect, this technique allows to match immovable background objects when other sprites partially obscure them. Note that both paper and ink pixels participate in matching procedure. Thus, for example, an empty (paper-only) 8x8 block has 32 matching pixels with any half-ink/half-paper block. Sound rules Sound rules let you add your own music and sound effects to the game. Their basic syntax is similar to the syntax of sprite replacement rules: <channel-number> <rule-type>[|x,y] <original-sprite> <sound-sample-file(s)> <event> [flags] Channels Every playback event is associated with an integer channel number. A single channel cannot be shared between two active playback events. If you start playback on the given channel, the previously active playback session of this channel will be interrupted. Zero channel is \"exclusive\": initiating a playback on the channel 0 will interrupt all other active playback events. Sound rule types Sound rules are triggered with the same pattern matching routines as sprite replacement rules. Hence, there are two types of sound rules: sound-block and sound-pixel . The <original-sprite> declaration also follows the syntax used in replacement rules. Events Sound playback is initiated when a specified events occurs. Currently, there are two types of sound events: appears : occurs when the given sprite appears on the screen (it is found now, but was not found on the previous frame); disappears : occurs when the given sprite disappears from the screen (it is not found now, but was found on the previous frame). Events are used to initiate a playback; there are no dedicated means for stopping a playback. However, it is possible to play an empty/silent sound file on the given channel to achieve the same outcome. Sound samples A sound sample is a conventional audio file. A variety of formats are supported, including MP3, WAV, and OGG. It is possible to specify a list of | -separated samples in one rule. When the rule is triggered, a random sample from the list will be chosen (unless seq flag is specified). Flags There are additional flags affecting the work of the sound engine: mute_ay : AY sound processor will be turned off while the rule is active; mute_beeper : regular ZX beeper will be turned off while the rule is active; volume|N : a sound sample will be played with the specified volume (0-100); loop : a sound sample will be looped until interrupted by another rule; seq : samples in a list of samples will be chosen sequentially rather than randomly.","title":"Writing rules"},{"location":"rules-syntax.html#writing-rules","text":"This section is intended to be a succint yet complete description of rule types and rule syntax. It might be a bit difficult to read it due to lack of practical examples, so make sure to check out Tips and tricks section as well.","title":"Writing rules"},{"location":"rules-syntax.html#settings-file","text":"All required game transformations are performed by means of rules, listed in the game\\settings.txt file. Each line of this file is a separate rule. Empty lines and lines starting with a semicolon symbol are ignored: ; This is a comment <here-comes-my-first-rule> Rules are case-sensitive.","title":"Settings file"},{"location":"rules-syntax.html#sprite-replacement-rules","text":"Each sprite replacement rule can substitute an original ZX Spectrum sprite found on the screen with its upgraded version. Recolored screen is twice wider and twice higher (512x384) than the original screen (256x192), and imposes no color limits. Sprite replacement rules are described with the following syntax: <layer-number> <rule-type>[|x,y] <original-sprite> <new-sprite> [protected|N]","title":"Sprite replacement rules"},{"location":"rules-syntax.html#layers","text":"If a game has non-blank background, it is necessary to ensure that foreground images (such as game characters) are drawn over the background rather than behind it. This can be achieved with layers: each subsequent layer is drawn only after the previous layer is complete. For example, all the sprites on the layer 1 will be drawn after all the sprites on the layer 0. The layer-number element should be an integer.","title":"Layers"},{"location":"rules-syntax.html#replacement-rule-types","text":"Currently there are two types of sprite replacement rules: block and pixel . ZX Spectrum screen is logically divided into 8x8-pixel blocks, having independent color palettes. In practice it means that immovable background elements are typically aligned with the borders of such blocks. Rules of block type search original sprites aligned with block corners only. In contrast, pixel rules check every location on the screen. There are two primary reasons to use block rules, where it is possible. First, they are much faster, since only block corner locations have to be checked. Second, they help fighting false positive matches. Sometimes, an accidental combination of pixels on the screen can form a \"match\" for a certain small sprite, causing the rule to trigger. If it is known that the original sprite is always block-aligned, we can minimize the chances of a false positive match. Rule type can be followed with an optional |x,y section, forcing the rule to be applicable to the original sprite located only in the specified position of the screen. This method is handy for detecting static elements displayed in known locations.","title":"Replacement rule types"},{"location":"rules-syntax.html#original-sprite-declaration","text":"Original sprite declaration consists of the following elements: <sprite-name>.bmp[|x1,y1,color1[|x2,y2,color2[|...]]] Color palette in ZX Spectrum is specified per 8x8 sprite block rather than per pixel. In practice it often leads to \"color clashes\" (incorrectly colored areas), apparent in many Spectrum games. For us it means that color matching is unreliable: we cannot be sure that the given sprite will always preserve its color palette. Therefore, the basic matching procedure assumes that the original sprite does not contain any color information. It should be a 24bpp BMP image, with a width equal to a multiple of 8, and actually containing pixels of these colors only: white, RGB(255, 255, 255) : background \"paper\" color; black, RGB(0, 0, 0) : foreground \"ink\" color; pinkish, RGB(242, 10, 242) : transparent color, ignored in matching operations. Sometimes, however, color information is both reliable and necessary. Thus, there is an option to specify a list of colors of individual sprite pixels. For example, the declaration my_sprite.bmp|0,0,red|0,1,yellow specifies that the match for my_sprite.bmp must have a black pixel in the top-left corner and a yellow pixel right under it. Color names are taken from the standard Spectrum vocabulary: black , blue , red , magenta , green , cyan , yellow , white . For brighter colors, add + to the color name: black+ , blue+ , red+ , magenta+ , green+ , cyan+ , yellow+ , white+ .","title":"Original sprite declaration"},{"location":"rules-syntax.html#recolored-sprite-declaration","text":"Declaring recolored sprites is easier: <new_sprite>.bmp[|dx,dy] Here the optional |dx,dy part allows to specify a relative displacement of the new sprite on the screen. For example, if you want to place the new sprite just a bit higher than the original matched fragment, use <new_sprite>.bmp|0,-1 Note that the numbers here correspond to the original ZX Spectrum screen dimensions. Thus, \"-1\" will actually become \"two pixels higher\" in the final double-size render.","title":"Recolored sprite declaration"},{"location":"rules-syntax.html#protected-clause","text":"The [protected|N] clause is one of handy tools designed to deal with incomplete matches. It works as follows: The system identifies missing protected sprites, matched on the previous frame. For each protected sprite, the system tries to match at least N non-transparent sprite pixels in the original location. If this is operation is successful, the sprite is considered found. In effect, this technique allows to match immovable background objects when other sprites partially obscure them. Note that both paper and ink pixels participate in matching procedure. Thus, for example, an empty (paper-only) 8x8 block has 32 matching pixels with any half-ink/half-paper block.","title":"Protected clause"},{"location":"rules-syntax.html#sound-rules","text":"Sound rules let you add your own music and sound effects to the game. Their basic syntax is similar to the syntax of sprite replacement rules: <channel-number> <rule-type>[|x,y] <original-sprite> <sound-sample-file(s)> <event> [flags]","title":"Sound rules"},{"location":"rules-syntax.html#channels","text":"Every playback event is associated with an integer channel number. A single channel cannot be shared between two active playback events. If you start playback on the given channel, the previously active playback session of this channel will be interrupted. Zero channel is \"exclusive\": initiating a playback on the channel 0 will interrupt all other active playback events.","title":"Channels"},{"location":"rules-syntax.html#sound-rule-types","text":"Sound rules are triggered with the same pattern matching routines as sprite replacement rules. Hence, there are two types of sound rules: sound-block and sound-pixel . The <original-sprite> declaration also follows the syntax used in replacement rules.","title":"Sound rule types"},{"location":"rules-syntax.html#events","text":"Sound playback is initiated when a specified events occurs. Currently, there are two types of sound events: appears : occurs when the given sprite appears on the screen (it is found now, but was not found on the previous frame); disappears : occurs when the given sprite disappears from the screen (it is not found now, but was found on the previous frame). Events are used to initiate a playback; there are no dedicated means for stopping a playback. However, it is possible to play an empty/silent sound file on the given channel to achieve the same outcome.","title":"Events"},{"location":"rules-syntax.html#sound-samples","text":"A sound sample is a conventional audio file. A variety of formats are supported, including MP3, WAV, and OGG. It is possible to specify a list of | -separated samples in one rule. When the rule is triggered, a random sample from the list will be chosen (unless seq flag is specified).","title":"Sound samples"},{"location":"rules-syntax.html#flags","text":"There are additional flags affecting the work of the sound engine: mute_ay : AY sound processor will be turned off while the rule is active; mute_beeper : regular ZX beeper will be turned off while the rule is active; volume|N : a sound sample will be played with the specified volume (0-100); loop : a sound sample will be looped until interrupted by another rule; seq : samples in a list of samples will be chosen sequentially rather than randomly.","title":"Flags"},{"location":"tips-and-tricks.html","text":"Tips and tricks Recoloring can be tricky at times. Here are some ideas to help you to deal with typical situations. Block and pixel matching If you are pretty sure that a certain sprite is always block-aligned, simply use a block-precise rule: 0 block zx_bow.bmp pc_bow.bmp zx_bow.bmp pc_bow.bmp If you are dealing with a moving object, use a pixel-precise rule, and don't forget about transparency, if the object moves over a non-solid background: 0 pixel zx_tank.bmp pc_tank.bmp zx_tank.bmp pc_tank.bmp result Remember, though, that Spectrum sprites can be quite deceptive. Sometimes you may have to deal with sprites that look like this: You might think that everything is clear: the character area shold be black, and the rest is transparent. However, this is often incorrect: if you try matching this image, you will get a perfect match for the sprite inside any solid black box! By providing a black-and-pinkish image, you are telling the system: I want these pixels to be of ink color, and I don't care about the rest. Thus, most images used for recognition should have areas of all three types: ink, paper, and transparent. Dealing with partial intersections If two objects you want see recolored intersect, plain full-sprite matching will not work. There are several ways to deal with this issue, so you will need to choose the right method depending on your particular case. If you believe that a large enough part of certain object will never be obscured, use it to recognize the full object. This is perhaps the most universal approach that works for all kinds of objects in all situations. However, if you choose a very small fragment for matching, you might get false positives (i.e., accidental matches in unexpected places). Use block matching, if possible, to reduce the chance of a false positive: ; note that two rules are used to recognize the block 0 pixel zx_pacman_block-1.bmp pc_pacman_block.bmp 0 pixel zx_pacman_block-2.bmp pc_pacman_block.bmp 1 pixel zx_pacman1.bmp pc_pacman1.bmp 1 pixel zx_pacman2.bmp pc_pacman2.bmp 1 pixel zx_pacman3.bmp pc_pacman3.bmp 1 pixel zx_pacman4.bmp pc_pacman4.bmp 1 pixel zx_pacman5.bmp pc_pacman5.bmp original recolored result If you want to recolor an immovable background object, the easiest solution is to use protected clause: 0 block zx_hurdle.bmp pc_hurdle.bmp protected|100 1 pixel horse1.bmp pc_horse1.bmp 1 pixel horse2.bmp pc_horse2.bmp 1 pixel horse3.bmp pc_horse3.bmp original recolored result Remember that the number of pixels checked by the protected keyword does not include transparent areas, so this value should be chosen carefully. Suppose you have an 8x8 box in your sprite, marked as a background. If the screens goes blank for some reason, the system will still think that at least 64 pixels of the original sprite are still there.","title":"Tips and tricks"},{"location":"tips-and-tricks.html#tips-and-tricks","text":"Recoloring can be tricky at times. Here are some ideas to help you to deal with typical situations.","title":"Tips and tricks"},{"location":"tips-and-tricks.html#block-and-pixel-matching","text":"If you are pretty sure that a certain sprite is always block-aligned, simply use a block-precise rule: 0 block zx_bow.bmp pc_bow.bmp zx_bow.bmp pc_bow.bmp If you are dealing with a moving object, use a pixel-precise rule, and don't forget about transparency, if the object moves over a non-solid background: 0 pixel zx_tank.bmp pc_tank.bmp zx_tank.bmp pc_tank.bmp result Remember, though, that Spectrum sprites can be quite deceptive. Sometimes you may have to deal with sprites that look like this: You might think that everything is clear: the character area shold be black, and the rest is transparent. However, this is often incorrect: if you try matching this image, you will get a perfect match for the sprite inside any solid black box! By providing a black-and-pinkish image, you are telling the system: I want these pixels to be of ink color, and I don't care about the rest. Thus, most images used for recognition should have areas of all three types: ink, paper, and transparent.","title":"Block and pixel matching"},{"location":"tips-and-tricks.html#dealing-with-partial-intersections","text":"If two objects you want see recolored intersect, plain full-sprite matching will not work. There are several ways to deal with this issue, so you will need to choose the right method depending on your particular case. If you believe that a large enough part of certain object will never be obscured, use it to recognize the full object. This is perhaps the most universal approach that works for all kinds of objects in all situations. However, if you choose a very small fragment for matching, you might get false positives (i.e., accidental matches in unexpected places). Use block matching, if possible, to reduce the chance of a false positive: ; note that two rules are used to recognize the block 0 pixel zx_pacman_block-1.bmp pc_pacman_block.bmp 0 pixel zx_pacman_block-2.bmp pc_pacman_block.bmp 1 pixel zx_pacman1.bmp pc_pacman1.bmp 1 pixel zx_pacman2.bmp pc_pacman2.bmp 1 pixel zx_pacman3.bmp pc_pacman3.bmp 1 pixel zx_pacman4.bmp pc_pacman4.bmp 1 pixel zx_pacman5.bmp pc_pacman5.bmp original recolored result If you want to recolor an immovable background object, the easiest solution is to use protected clause: 0 block zx_hurdle.bmp pc_hurdle.bmp protected|100 1 pixel horse1.bmp pc_horse1.bmp 1 pixel horse2.bmp pc_horse2.bmp 1 pixel horse3.bmp pc_horse3.bmp original recolored result Remember that the number of pixels checked by the protected keyword does not include transparent areas, so this value should be chosen carefully. Suppose you have an 8x8 box in your sprite, marked as a background. If the screens goes blank for some reason, the system will still think that at least 64 pixels of the original sprite are still there.","title":"Dealing with partial intersections"}]}