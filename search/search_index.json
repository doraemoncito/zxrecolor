{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"About Many developers draw inspiration from older games to create some really cool and admirable works. Writing a game, however, is a hard task, so it is no wonder that many decent games never get a modern remake. Arguably, many old games can be quite frustrating for a modern player, so an appealing remake should include ceratain updates for core game mechanics. However, many other games are still enjoyable to play, and it is often sufficient to update graphics and sound to please our modern senses. At least, this kind of logic is apparent in many great remakes like Head over Heels : If a game is playable enough, and it doesn't require a complete rewrite, can we upgrade it with less effort? ZX Recoloring Project aims to provide a toolset exactly for this purpose. There is no ambition to provide a solution for implementing all sorts of ideas in all sorts of games. The main focus is on simplicity of use: you can make your favorite game noticeably different less than in an hour, and keep adding new improvements gradually. The project is maintaned by Maxim Mozgovoy in frustratingly rare moments of his spare time.","title":"About"},{"location":"index.html#about","text":"Many developers draw inspiration from older games to create some really cool and admirable works. Writing a game, however, is a hard task, so it is no wonder that many decent games never get a modern remake. Arguably, many old games can be quite frustrating for a modern player, so an appealing remake should include ceratain updates for core game mechanics. However, many other games are still enjoyable to play, and it is often sufficient to update graphics and sound to please our modern senses. At least, this kind of logic is apparent in many great remakes like Head over Heels : If a game is playable enough, and it doesn't require a complete rewrite, can we upgrade it with less effort? ZX Recoloring Project aims to provide a toolset exactly for this purpose. There is no ambition to provide a solution for implementing all sorts of ideas in all sorts of games. The main focus is on simplicity of use: you can make your favorite game noticeably different less than in an hour, and keep adding new improvements gradually. The project is maintaned by Maxim Mozgovoy in frustratingly rare moments of his spare time.","title":"About"},{"location":"handy-tools.html","text":"Handy tools While you can manage any recoloring project solely with the help of your favorite graphics editor, there are additional tools aimed to make this job easier. Please check them out. UnrealSpeccy Emulator UnrealSpeccy includes numerous developer-oriented instruments, and some additional means are added to our customized version. Here is a very incomplete list: Ctrl+1 , Ctrl+2 , Ctrl+3 : switch between recolored, original, and black-and-white rendering. Alt+F8 : take a screenshot. Ctrl+8 : record a video clip (you will need to have ffmpeg.exe in the emulator folder). You can change target video format in unreal.ini : search for \"ffmpeg encoding options\". Also note that the resulting video will be placed into the \"current folder\", which is game if you have already created it. hqx Many emulators improve video output by means of hqx filter . Hqx-processed screenshots can be a good start for subsequent recoloring work. ZX Recoloring project includes a precompiled version of hqx command line tool. Run it with the original (unscaled) ZX Spectrum screenshot as an input argument to generate a double-sized hqx-improved output.bmp ZX Color Tool TODO <!-- A simple auxiliary instrument called ZX Color Tool is designed to edit sprite pairs conveniently: The main purpose of the tool is extraction of individual sprites out of a specifically marked-up image. It is quite hard to work with dozens of separate drawings. It is much easier to collect them into a single screen and to draw borders manually. Then ZX Color Tool will be able to save screen fragments as independent sprites automatically. Let's consider elements of the tool's main form: The Load Image button loads an image with sprites for further processing. In ZX mode the tool doubles the size of the image before displaying it (assuming that a user wants to load a ZX Spectrum screenshot with original-sized sprites). The button with an arrow (>) adds a new object to the objects collection. The object name should be specified in the textfield to the left of the button. If a certain object is selected in the Objects list, the bounds of the corresponding screen sprite can be adjusted by left (left-up corner) and right (right-down corner) mouse clicks. The work with objects list is performed with Del (delete object), New (clear objects list), Load (load another objects list) and Save (save objects list) buttons. The Split button runs the process of sprites splitting. The ready images will be saved in the subfolder Output. Since original ZX sprites are rescaled while displaying on the ZX Color Tool's main form, the same objects list can be used both for image with original sprites, and for image with thir recolored counterparts. In general, the process of game modernization can look as follows: Place all original Spectrum sprites into zx_game.bmp file. Double the dimensions of this image and save it as pc_game.bmp. Using ZX Color Tool, mark-up the original sprites of zx_game.bmp. The name of each object is reasonable to start with prefix zx_. The objects list should be saved in file zx_objects.txt. Copy the contents of the file zx_objects.txt into the file pc_objects.txt. Edit the file pc_objects.txt by replacing all occurrences of the substring zx_ with the string pc_. Update the sprites in the file pc_game.bmp. Now it is possible to extract individual sprites from the collections using Split button. While updating the graphics, it is neccessary to make sure that each new sprite covers its original counterpart completely. Otherwise some fragments of original sprites would be visible on the screen, too. It is generally not recommended to depart too much from the original palette of moving objects. If the system would be unable to find a sprite due to some reason (for example, if the sprite is heavily covered with other objects), the displayed original sprite would be not so noticeable. -->","title":"Handy tools"},{"location":"handy-tools.html#handy-tools","text":"While you can manage any recoloring project solely with the help of your favorite graphics editor, there are additional tools aimed to make this job easier. Please check them out.","title":"Handy tools"},{"location":"handy-tools.html#unrealspeccy-emulator","text":"UnrealSpeccy includes numerous developer-oriented instruments, and some additional means are added to our customized version. Here is a very incomplete list: Ctrl+1 , Ctrl+2 , Ctrl+3 : switch between recolored, original, and black-and-white rendering. Alt+F8 : take a screenshot. Ctrl+8 : record a video clip (you will need to have ffmpeg.exe in the emulator folder). You can change target video format in unreal.ini : search for \"ffmpeg encoding options\". Also note that the resulting video will be placed into the \"current folder\", which is game if you have already created it.","title":"UnrealSpeccy Emulator"},{"location":"handy-tools.html#hqx","text":"Many emulators improve video output by means of hqx filter . Hqx-processed screenshots can be a good start for subsequent recoloring work. ZX Recoloring project includes a precompiled version of hqx command line tool. Run it with the original (unscaled) ZX Spectrum screenshot as an input argument to generate a double-sized hqx-improved output.bmp","title":"hqx"},{"location":"handy-tools.html#zx-color-tool","text":"TODO <!-- A simple auxiliary instrument called ZX Color Tool is designed to edit sprite pairs conveniently: The main purpose of the tool is extraction of individual sprites out of a specifically marked-up image. It is quite hard to work with dozens of separate drawings. It is much easier to collect them into a single screen and to draw borders manually. Then ZX Color Tool will be able to save screen fragments as independent sprites automatically. Let's consider elements of the tool's main form: The Load Image button loads an image with sprites for further processing. In ZX mode the tool doubles the size of the image before displaying it (assuming that a user wants to load a ZX Spectrum screenshot with original-sized sprites). The button with an arrow (>) adds a new object to the objects collection. The object name should be specified in the textfield to the left of the button. If a certain object is selected in the Objects list, the bounds of the corresponding screen sprite can be adjusted by left (left-up corner) and right (right-down corner) mouse clicks. The work with objects list is performed with Del (delete object), New (clear objects list), Load (load another objects list) and Save (save objects list) buttons. The Split button runs the process of sprites splitting. The ready images will be saved in the subfolder Output. Since original ZX sprites are rescaled while displaying on the ZX Color Tool's main form, the same objects list can be used both for image with original sprites, and for image with thir recolored counterparts. In general, the process of game modernization can look as follows: Place all original Spectrum sprites into zx_game.bmp file. Double the dimensions of this image and save it as pc_game.bmp. Using ZX Color Tool, mark-up the original sprites of zx_game.bmp. The name of each object is reasonable to start with prefix zx_. The objects list should be saved in file zx_objects.txt. Copy the contents of the file zx_objects.txt into the file pc_objects.txt. Edit the file pc_objects.txt by replacing all occurrences of the substring zx_ with the string pc_. Update the sprites in the file pc_game.bmp. Now it is possible to extract individual sprites from the collections using Split button. While updating the graphics, it is neccessary to make sure that each new sprite covers its original counterpart completely. Otherwise some fragments of original sprites would be visible on the screen, too. It is generally not recommended to depart too much from the original palette of moving objects. If the system would be unable to find a sprite due to some reason (for example, if the sprite is heavily covered with other objects), the displayed original sprite would be not so noticeable. -->","title":"ZX Color Tool"},{"location":"hello-world.html","text":"Hello, world! For starters, let's try to recolor a couple of sprites in a small game titled I, Ball II . Download and extract the archive iball2.zip . It contains a minimal binary distribution of an open source Spectrum emulator Unreal Speccy (the main executable file is renamed into iball2.exe ), and a SNA image of I, Ball II. The snapshot is taken at the beginning of level 2, since it contains the sprites of our interest. Run the game (i.e., execute iball2.exe ) and make sure that everything works correctly. The controls are set to Sinclair joystick (keyboard keys 6, 7, 8, 9, 0). Initially, the game screen should look like this: Now let's update the sprites of yellow balls and gray boxes: Create a subfolder game inside the game folder. Here you should place both the old sprite pictures you want to substitute and their upgraded versions. For the balls and the boxes you'll need these pictures . Create in the same game subfolder a file settings.txt , containing the following lines: 0 block zx_yellowball.bmp pc_yellowball.bmp 0 pixel zx_graybrick.bmp pc_graybrick.bmp That's it! Run the game and enjoy the result: Some final notes: Recolored screen is twice wider and twice higher than the original ZX Spectrum screen, so in most cases recolored sprites should also be twice wider and twice higher than their original counterparts. Both original and recolored sprites should be stored in the BMP 24bpp format. Areas painted with the pinkish color RGB(242, 10, 242) are treated as transparent. All non-transparent pixels in the original sprites must be either black (ink) or white (paper). The configuration file settings.txt consists of lines including at least the following compulsory elements: <layer-number> <rule-type> <original-sprite> <new-sprite> Layers are needed to organize background and foreground elements properly. The system draws sprites layer by layer, so foreground sprites should be placed on higher-numbered layers. Different rule types are used here to reduce CPU load. Fast cell-precise block rules assume that the original sprites are always aligned with the borders of 8x8 pixel blocks (which is a very common case for background objects). In contrast, slower pixel-precise pixel rules perform complete searching. In our case, yellow balls never leave their initial positions, so cell-precise matching is sufficient. However, gray boxes fall down when touched, so pixel-precise matching is necessary in their case. In practice everything is usually not so simple. Keep reading!","title":"Hello, world!"},{"location":"hello-world.html#hello-world","text":"For starters, let's try to recolor a couple of sprites in a small game titled I, Ball II . Download and extract the archive iball2.zip . It contains a minimal binary distribution of an open source Spectrum emulator Unreal Speccy (the main executable file is renamed into iball2.exe ), and a SNA image of I, Ball II. The snapshot is taken at the beginning of level 2, since it contains the sprites of our interest. Run the game (i.e., execute iball2.exe ) and make sure that everything works correctly. The controls are set to Sinclair joystick (keyboard keys 6, 7, 8, 9, 0). Initially, the game screen should look like this: Now let's update the sprites of yellow balls and gray boxes: Create a subfolder game inside the game folder. Here you should place both the old sprite pictures you want to substitute and their upgraded versions. For the balls and the boxes you'll need these pictures . Create in the same game subfolder a file settings.txt , containing the following lines: 0 block zx_yellowball.bmp pc_yellowball.bmp 0 pixel zx_graybrick.bmp pc_graybrick.bmp That's it! Run the game and enjoy the result: Some final notes: Recolored screen is twice wider and twice higher than the original ZX Spectrum screen, so in most cases recolored sprites should also be twice wider and twice higher than their original counterparts. Both original and recolored sprites should be stored in the BMP 24bpp format. Areas painted with the pinkish color RGB(242, 10, 242) are treated as transparent. All non-transparent pixels in the original sprites must be either black (ink) or white (paper). The configuration file settings.txt consists of lines including at least the following compulsory elements: <layer-number> <rule-type> <original-sprite> <new-sprite> Layers are needed to organize background and foreground elements properly. The system draws sprites layer by layer, so foreground sprites should be placed on higher-numbered layers. Different rule types are used here to reduce CPU load. Fast cell-precise block rules assume that the original sprites are always aligned with the borders of 8x8 pixel blocks (which is a very common case for background objects). In contrast, slower pixel-precise pixel rules perform complete searching. In our case, yellow balls never leave their initial positions, so cell-precise matching is sufficient. However, gray boxes fall down when touched, so pixel-precise matching is necessary in their case. In practice everything is usually not so simple. Keep reading!","title":"Hello, world!"},{"location":"rules-syntax.html","text":"Writing rules This section is intended to be a succint yet complete description of rule types and rule syntax. It might be a bit difficult to read it due to lack of practical examples, so make sure to check out Tips and tricks section as well. Settings file All required game transformations are performed by means of rules, listed in the game\\settings.txt file. Each line of this file is a separate rule. Empty lines and lines starting with a semicolon symbol are ignored: ; This is a comment <here-comes-my-first-rule> Rules are case-sensitive. Sprite replacement rules Each sprite replacement rule can substitute an original ZX Spectrum sprite found on the screen with its upgraded version. Recolored screen is twice wider and twice higher (512x384) than the original screen (256x192), and imposes no color limits. Sprite replacement rules are described with the following syntax: <layer-number> <rule-type> <original-sprite> <new-sprite> [protected|N] Layers If a game has non-blank background, it is necessary to ensure that foreground images (such as game characters) are drawn over the background rather than behind it. This can be achieved with layers: each subsequent layer is drawn only after the previous layer is complete. For example, all the sprites on the layer 1 will be drawn after all the sprites on the layer 0. The layer-number element should be an integer. Replacement rule types Currently there are two types of sprite replacement rules: block and pixel . ZX Spectrum screen is logically divided into 8x8-pixel blocks, having independent color palettes. In practice it means that immovable background elements are typically aligned with the borders of such blocks. Rules of block type search original sprites aligned with block corners only. In contrast, pixel rules check every location on the screen. There are two primary reasons to use block rules, where it is possible. First, they are much faster, since only block corner locations have to be checked. Second, they help fighting false positive matches. Sometimes, an accidental combination of pixels on the screen can form a \"match\" for a certain small sprite, causing the rule to trigger. If it is known that the original sprite is always block-aligned, we can minimize the chances of a false positive match. Original sprite declaration Original sprite declaration consists of the following elements: <sprite-name>.bmp[|x1,y1,color1[|x2,y2,color2[|...]]] Color palette in ZX Spectrum is specified per 8x8 sprite block rather than per pixel. In practice it often leads to \"color clashes\" (incorrectly colored areas), apparent in many Spectrum games. For us it means that color matching is unreliable: we cannot be sure that the given sprite will always preserve its color palette. Therefore, the basic matching procedure assumes that the original sprite does not contain any color information. It should be a 24bpp BMP image actually containing pixels of these colors only: white, RGB(255, 255, 255) : background \"paper\" color; black, RGB(0, 0, 0) : foreground \"ink\" color; pinkish, RGB(242, 10, 242) : transparent color, ignored in matching operations. Sometimes, however, color information is both reliable and necessary. Thus, there is an option to specify a list of colors of individual sprite pixels. For example, the declaration my_sprite.bmp|0,0,red|0,1,yellow specifies that the match for my_sprite.bmp must have a black pixel in the top-left corner and a yellow pixel right under it. Color names are taken from the standard Spectrum vocabulary: black , blue , red , magenta , green , cyan , yellow , white . For brighter colors, add + to the color name: black+ , blue+ , red+ , magenta+ , green+ , cyan+ , yellow+ , white+ . Recolored sprite declaration Declaring recolored sprites is easier: <new_sprite>.bmp[|dx,dy] Here the optional |dx,dy part allows to specify a relative displacement of the new sprite on the screen. For example, if you want to place the new sprite just a bit higher than the original matched fragment, use <new_sprite>.bmp|0,-1 Note that the numbers here correspond to the original ZX Spectrum screen dimensions. Thus, \"-1\" will actually become \"two pixels higher\" in the final double-size render. Protected clause The [protected|N] clause is one of handy tools designed to deal with incomplete matches. It works as follows: The system identifies missing protected sprites, matched on the previous frame. For each protected sprite, the system tries to match at least N non-transparent sprite pixels in the original location. If this is operation is successful, the sprite is considered found. In effect, this technique allows to match immovable background objects when other sprites partially obscure them. Note that both paper and ink pixels participate in matching procedure. Thus, for example, an empty (paper-only) 8x8 block has 32 matching pixels with any half-ink/half-paper block. Sound rules Sound rules let you add your own music and sound effects to the game. Their basic syntax is similar to the syntax of sprite replacement rules: <channel-number> <rule-type> <original-sprite> <sound-sample-file> <event> [flags] Channels Every playback event is associated with an integer channel number. A single channel cannot be shared between two active playback events. If you start playback on the given channel, the previously active playback session of this channel will be interrupted. Zero channel is \"exclusive\": initiating a playback on the channel 0 will interrupt all other active playback events. Sound rule types Sound rules are triggered with the same pattern matching routines as sprite replacement rules. Hence, there are two types of sound rules: sound-block and sound-pixel . The <original-sprite> declaration also follows the syntax used in replacement rules. Events Sound playback is initiated when a specified events occurs. Currently, there are two types of sound events: appears : occurs when the given sprite appears on the screen (it is found now, but was not found on the previous frame); disappears : occurs when the given sprite disappears from the screen (it is not found now, but was found on the previous frame). Events are used to initiate a playback; there are no dedicated means for stopping a playback. However, it is possible to play an empty/silent sound file on the given channel to achieve the same outcome. Sound samples A sound sample is a conventional audio file. A variety of formats are supported, including MP3, WAV, and OGG. Flags You may want to mute regular Spectrum sound output while playing your custom samples. This is achieved with mute_ay and mute_beeper flags: mute_ay : AY sound processor will be turned off while the rule is active; mute_beeper : regular ZX beeper will be turned off while the rule is active. This way, regular sound system of Spectrum will be turned on only if there are no active rules with these flags set.","title":"Writing rules"},{"location":"rules-syntax.html#writing-rules","text":"This section is intended to be a succint yet complete description of rule types and rule syntax. It might be a bit difficult to read it due to lack of practical examples, so make sure to check out Tips and tricks section as well.","title":"Writing rules"},{"location":"rules-syntax.html#settings-file","text":"All required game transformations are performed by means of rules, listed in the game\\settings.txt file. Each line of this file is a separate rule. Empty lines and lines starting with a semicolon symbol are ignored: ; This is a comment <here-comes-my-first-rule> Rules are case-sensitive.","title":"Settings file"},{"location":"rules-syntax.html#sprite-replacement-rules","text":"Each sprite replacement rule can substitute an original ZX Spectrum sprite found on the screen with its upgraded version. Recolored screen is twice wider and twice higher (512x384) than the original screen (256x192), and imposes no color limits. Sprite replacement rules are described with the following syntax: <layer-number> <rule-type> <original-sprite> <new-sprite> [protected|N]","title":"Sprite replacement rules"},{"location":"rules-syntax.html#layers","text":"If a game has non-blank background, it is necessary to ensure that foreground images (such as game characters) are drawn over the background rather than behind it. This can be achieved with layers: each subsequent layer is drawn only after the previous layer is complete. For example, all the sprites on the layer 1 will be drawn after all the sprites on the layer 0. The layer-number element should be an integer.","title":"Layers"},{"location":"rules-syntax.html#replacement-rule-types","text":"Currently there are two types of sprite replacement rules: block and pixel . ZX Spectrum screen is logically divided into 8x8-pixel blocks, having independent color palettes. In practice it means that immovable background elements are typically aligned with the borders of such blocks. Rules of block type search original sprites aligned with block corners only. In contrast, pixel rules check every location on the screen. There are two primary reasons to use block rules, where it is possible. First, they are much faster, since only block corner locations have to be checked. Second, they help fighting false positive matches. Sometimes, an accidental combination of pixels on the screen can form a \"match\" for a certain small sprite, causing the rule to trigger. If it is known that the original sprite is always block-aligned, we can minimize the chances of a false positive match.","title":"Replacement rule types"},{"location":"rules-syntax.html#original-sprite-declaration","text":"Original sprite declaration consists of the following elements: <sprite-name>.bmp[|x1,y1,color1[|x2,y2,color2[|...]]] Color palette in ZX Spectrum is specified per 8x8 sprite block rather than per pixel. In practice it often leads to \"color clashes\" (incorrectly colored areas), apparent in many Spectrum games. For us it means that color matching is unreliable: we cannot be sure that the given sprite will always preserve its color palette. Therefore, the basic matching procedure assumes that the original sprite does not contain any color information. It should be a 24bpp BMP image actually containing pixels of these colors only: white, RGB(255, 255, 255) : background \"paper\" color; black, RGB(0, 0, 0) : foreground \"ink\" color; pinkish, RGB(242, 10, 242) : transparent color, ignored in matching operations. Sometimes, however, color information is both reliable and necessary. Thus, there is an option to specify a list of colors of individual sprite pixels. For example, the declaration my_sprite.bmp|0,0,red|0,1,yellow specifies that the match for my_sprite.bmp must have a black pixel in the top-left corner and a yellow pixel right under it. Color names are taken from the standard Spectrum vocabulary: black , blue , red , magenta , green , cyan , yellow , white . For brighter colors, add + to the color name: black+ , blue+ , red+ , magenta+ , green+ , cyan+ , yellow+ , white+ .","title":"Original sprite declaration"},{"location":"rules-syntax.html#recolored-sprite-declaration","text":"Declaring recolored sprites is easier: <new_sprite>.bmp[|dx,dy] Here the optional |dx,dy part allows to specify a relative displacement of the new sprite on the screen. For example, if you want to place the new sprite just a bit higher than the original matched fragment, use <new_sprite>.bmp|0,-1 Note that the numbers here correspond to the original ZX Spectrum screen dimensions. Thus, \"-1\" will actually become \"two pixels higher\" in the final double-size render.","title":"Recolored sprite declaration"},{"location":"rules-syntax.html#protected-clause","text":"The [protected|N] clause is one of handy tools designed to deal with incomplete matches. It works as follows: The system identifies missing protected sprites, matched on the previous frame. For each protected sprite, the system tries to match at least N non-transparent sprite pixels in the original location. If this is operation is successful, the sprite is considered found. In effect, this technique allows to match immovable background objects when other sprites partially obscure them. Note that both paper and ink pixels participate in matching procedure. Thus, for example, an empty (paper-only) 8x8 block has 32 matching pixels with any half-ink/half-paper block.","title":"Protected clause"},{"location":"rules-syntax.html#sound-rules","text":"Sound rules let you add your own music and sound effects to the game. Their basic syntax is similar to the syntax of sprite replacement rules: <channel-number> <rule-type> <original-sprite> <sound-sample-file> <event> [flags]","title":"Sound rules"},{"location":"rules-syntax.html#channels","text":"Every playback event is associated with an integer channel number. A single channel cannot be shared between two active playback events. If you start playback on the given channel, the previously active playback session of this channel will be interrupted. Zero channel is \"exclusive\": initiating a playback on the channel 0 will interrupt all other active playback events.","title":"Channels"},{"location":"rules-syntax.html#sound-rule-types","text":"Sound rules are triggered with the same pattern matching routines as sprite replacement rules. Hence, there are two types of sound rules: sound-block and sound-pixel . The <original-sprite> declaration also follows the syntax used in replacement rules.","title":"Sound rule types"},{"location":"rules-syntax.html#events","text":"Sound playback is initiated when a specified events occurs. Currently, there are two types of sound events: appears : occurs when the given sprite appears on the screen (it is found now, but was not found on the previous frame); disappears : occurs when the given sprite disappears from the screen (it is not found now, but was found on the previous frame). Events are used to initiate a playback; there are no dedicated means for stopping a playback. However, it is possible to play an empty/silent sound file on the given channel to achieve the same outcome.","title":"Events"},{"location":"rules-syntax.html#sound-samples","text":"A sound sample is a conventional audio file. A variety of formats are supported, including MP3, WAV, and OGG.","title":"Sound samples"},{"location":"rules-syntax.html#flags","text":"You may want to mute regular Spectrum sound output while playing your custom samples. This is achieved with mute_ay and mute_beeper flags: mute_ay : AY sound processor will be turned off while the rule is active; mute_beeper : regular ZX beeper will be turned off while the rule is active. This way, regular sound system of Spectrum will be turned on only if there are no active rules with these flags set.","title":"Flags"},{"location":"tips-and-tricks.html","text":"Tips and tricks TODO","title":"Tips and tricks"},{"location":"tips-and-tricks.html#tips-and-tricks","text":"TODO","title":"Tips and tricks"}]}